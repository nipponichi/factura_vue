import { defineComponent as M, ref as p, watch as z, onMounted as X, onBeforeUnmount as x, openBlock as g, createElementBlock as m, createElementVNode as T, normalizeStyle as R, computed as w, normalizeClass as N, createBlock as F, resolveDynamicComponent as se, createCommentVNode as _, getCurrentInstance as ee, onUnmounted as re, resolveComponent as A, withDirectives as ie, vShow as ae, toDisplayString as G, Fragment as te, renderList as ne, reactive as le, readonly as de, TransitionGroup as ue, withCtx as oe, renderSlot as ce, nextTick as ve, createVNode as ge, createApp as fe } from "vue";
/*! ================================
vue-toastify v2.0.0-alpha.2
(c) 2019-present Nandor Kraszlan
Released under MIT License
================================== */
const S = {
  vtDragFinished: [],
  vtBeingDragged: [],
  vtDragStarted: [],
  vtDismissed: [],
  vtStarted: [],
  vtFinished: [],
  vtLoadStop: [],
  vtPromptResponse: [],
  vtPaused: [],
  vtResumed: []
};
function P() {
  return {
    on(e, t) {
      S[e] || (S[e] = []), S[e].push(t);
    },
    once(e, t) {
      const n = (r) => {
        t(r), this.off(e, n);
      };
      this.on(e, n);
    },
    off(e, t) {
      S[e] && (t ? S[e] = S[e].filter((n) => n !== t) : S[e] = []);
    },
    emit(e, t) {
      S[e] && S[e].forEach((n) => n(t));
    }
  };
}
const me = M({
  name: "ProgressBar",
  props: {
    isPaused: { type: Boolean },
    duration: { type: Number, default: 0 },
    id: { type: String, required: !0 }
  },
  emits: ["vtFinished"],
  expose: ["progress"],
  setup: (e, t) => {
    const n = p(0), r = p(), l = p(), d = p(/* @__PURE__ */ new Date()), u = p(/* @__PURE__ */ new Date()), i = p(new Date(e.duration + Date.now())), a = P(), f = () => {
      d.value = new Date(
        d.value.getTime() + (Date.now() - u.value.getTime())
      ), i.value = new Date(
        i.value.getTime() + (Date.now() - u.value.getTime())
      ), !l.value && n.value > 0 && a.emit("vtResumed", { id: e.id }), l.value = window.setTimeout(
        () => t.emit("vtFinished"),
        i.value.getTime() - Date.now()
      ), r.value = requestAnimationFrame(h);
    }, $ = () => {
      window.clearTimeout(l.value), l.value = void 0, cancelAnimationFrame(r.value), r.value = void 0, a.emit("vtPaused", { id: e.id }), u.value = /* @__PURE__ */ new Date();
    }, h = () => {
      if (n.value < 100) {
        const C = i.value.getTime() - d.value.getTime(), L = Date.now() - d.value.getTime();
        n.value = L / C * 100, l.value && (r.value = requestAnimationFrame(h));
      } else
        cancelAnimationFrame(r.value), r.value = void 0;
    };
    return z(() => e.isPaused, (C) => C ? $() : f()), X(() => {
      a.emit("vtStarted", { id: e.id }), f();
    }), x(() => {
      n.value = 0, window.clearTimeout(l.value), r.value && (cancelAnimationFrame(r.value), r.value = void 0);
    }), {
      progress: n
    };
  }
}), j = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, l] of t)
    n[r] = l;
  return n;
}, pe = { class: "vt-progress-bar" };
function he(e, t, n, r, l, d) {
  return g(), m("div", pe, [
    T("div", {
      class: "vt-progress",
      style: R({ width: e.progress + "%" })
    }, null, 4)
  ]);
}
const ye = /* @__PURE__ */ j(me, [["render", he]]), I = (e) => typeof e == "boolean";
function be(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
const we = (e, t, n) => e > t && e <= n, Te = () => {
  const e = /[018]/g, t = (n) => (n ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> n / 4).toString(16);
  return "10000000-1000-4000-8000-100000000000".replace(e, t);
}, $e = M({
  name: "VtIcon",
  props: {
    mode: { type: String },
    type: { type: String },
    icon: { type: [Object, String] },
    baseIconClass: { type: String, default: "" }
  },
  setup: (e) => {
    const t = w(() => {
      if (!e.icon)
        return !1;
      let r = {
        tag: "i",
        ligature: "",
        class: e.baseIconClass
      };
      return typeof e.icon == "string" && (e.icon.toLowerCase().includes("<svg") ? (r.tag = "div", r.ligature = e.icon) : r.class = r.class + " " + e.icon), be(e.icon) && (r = Object.assign(r, e.icon)), r;
    }), n = w(() => {
      const r = {};
      return e.mode !== "loader" && (r["vt-circle"] = !e.icon), r["vt-prompt"] = e.mode === "prompt", (e.mode === void 0 || e.mode.length === 0) && (r["vt-" + (e.type ? e.type : "info")] = !0), r;
    });
    return {
      userIcon: t,
      containerClasses: n
    };
  }
}), Le = {
  key: 1,
  class: "vt-spinner"
}, Ce = {
  key: 2,
  class: "vt-icon"
}, Ee = {
  style: { width: "24px", height: "24px" },
  viewBox: "0 0 24 24"
}, Se = /* @__PURE__ */ T("path", { d: `M10,19H13V22H10V19M12,2C17.35,2.22 19.68,7.62 16.5,11.67C15.67,12.67 14.33,13.33
                       13.67,14.17C13,15 13,16 13,17H10C10,15.33 10,13.92 10.67,12.92C11.33,11.92 12.67,11.33
                       13.5,10.67C15.92,8.43 15.32,5.26 12,5A3,3 0 0,0 9,8H6A6,6 0 0,1 12,2Z` }, null, -1), De = [
  Se
], ke = {
  key: 3,
  class: "vt-icon"
}, Ie = /* @__PURE__ */ T("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "36",
  height: "36",
  viewBox: "0 0 24 24"
}, [
  /* @__PURE__ */ T("path", { d: `M9 16.2l-3.5-3.5c-.39-.39-1.01-.39-1.4 0-.39.39-.39 1.01 0 1.4l4.19 4.19c.39.39 1.02.39 1.41
                         0L20.3 7.7c.39-.39.39-1.01 0-1.4-.39-.39-1.01-.39-1.4 0L9 16.2z` })
], -1), Be = [
  Ie
], Oe = {
  key: 4,
  class: "vt-icon"
}, _e = /* @__PURE__ */ T("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "36",
  height: "36",
  viewBox: "0 0 24 24"
}, [
  /* @__PURE__ */ T("path", { d: `M18.3 5.71c-.39-.39-1.02-.39-1.41 0L12 10.59 7.11 5.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02
                         0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89
                         4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z` })
], -1), Ve = [
  _e
], Ne = {
  key: 5,
  class: "vt-icon"
}, Fe = /* @__PURE__ */ T("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "36",
  height: "36",
  viewBox: "0 0 24 24"
}, [
  /* @__PURE__ */ T("circle", {
    cx: "12",
    cy: "19",
    r: "2"
  }),
  /* @__PURE__ */ T("path", { d: "M12 3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2s2-.9 2-2V5c0-1.1-.9-2-2-2z" })
], -1), Me = [
  Fe
], Pe = {
  key: 6,
  class: "vt-icon"
}, je = {
  xmlns: "http://www.w3.org/2000/svg",
  style: { transform: "rotate(180deg)" },
  width: "36",
  height: "36",
  viewBox: "0 0 24 24"
}, He = /* @__PURE__ */ T("path", { d: "M12 3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2s2-.9 2-2V5c0-1.1-.9-2-2-2z" }, null, -1), Re = /* @__PURE__ */ T("circle", {
  cx: "12",
  cy: "19",
  r: "2"
}, null, -1), Ae = [
  He,
  Re
];
function qe(e, t, n, r, l, d) {
  return g(), m("div", {
    class: N(["vt-icon-container", e.containerClasses])
  }, [
    e.userIcon ? (g(), F(se(e.userIcon.tag), {
      key: 0,
      class: N(["vt-icon", e.userIcon.class]),
      innerHTML: e.userIcon.ligature
    }, null, 8, ["class", "innerHTML"])) : e.mode === "loader" ? (g(), m("div", Le)) : e.mode === "prompt" ? (g(), m("div", Ce, [
      (g(), m("svg", Ee, De))
    ])) : e.containerClasses["vt-success"] ? (g(), m("div", ke, Be)) : e.containerClasses["vt-error"] ? (g(), m("div", Oe, Ve)) : e.containerClasses["vt-warning"] ? (g(), m("div", Ne, Me)) : e.containerClasses["vt-info"] ? (g(), m("div", Pe, [
      (g(), m("svg", je, Ae))
    ])) : _("", !0)
  ], 2);
}
const ze = /* @__PURE__ */ j($e, [["render", qe]]);
function K(e) {
  return "targetTouches" in e && e.targetTouches.length > 0 ? e.targetTouches[0].clientX : e.clientX;
}
function Q(e) {
  return "targetTouches" in e && e.targetTouches.length > 0 ? e.targetTouches[0].clientY : e.clientY;
}
function Ue(e, t) {
  const n = ee(), r = p(), l = p(), d = p(!1), u = p(), i = P(), a = w(() => {
    var c;
    return (c = n.proxy) == null ? void 0 : c.$el;
  }), f = w(() => {
    var c;
    return !!l.value && ((c = r.value) == null ? void 0 : c.x) !== l.value.x;
  }), $ = w(() => d.value ? l.value.x - r.value.x : 0), h = w(() => u.value ? u.value.width * e.status.dragThreshold : 15), C = w(() => {
    if (!d.value || l.value !== void 0 && r.value !== void 0 && r.value.x === l.value.x || !f.value)
      return {};
    let c = 1 - Math.abs($.value / h.value);
    return c = isNaN(c) ? 1 : c, {
      transform: `translateX(${$.value}px)`,
      opacity: String(c),
      userSelect: "none"
    };
  }), L = (c) => {
    a.value.classList.toggle("vt-will-change"), d.value = !0, r.value = { x: K(c), y: Q(c) }, u.value = a.value.getBoundingClientRect();
  }, E = (c) => {
    c.preventDefault(), d.value && (l.value = { x: K(c), y: Q(c) }, f.value ? i.emit("vtBeingDragged", {
      id: e.status.id,
      position: l.value
    }) : i.emit("vtDragStarted", {
      id: e.status.id,
      position: r.value
    }));
  }, k = () => {
    f.value && (i.emit("vtDragFinished", {
      id: e.status.id,
      position: l.value
    }), a.value.getBoundingClientRect().right > window.innerWidth && a.value.getBoundingClientRect().right - window.innerWidth > u.value.width * 0.75, a.value.getBoundingClientRect().right < u.value.width * 0.25, Math.abs(u.value.left - a.value.getBoundingClientRect().left) > h.value && t(), d.value = !1, setTimeout(() => {
      l.value = void 0, r.value = void 0, u.value = void 0, a.value.classList.toggle("vt-will-change");
    }));
  };
  return e.status.draggable && (X(() => {
    a.value.addEventListener("touchstart", L), a.value.addEventListener("mousedown", L), addEventListener("touchmove", E), addEventListener("mousemove", E), addEventListener("touchend", k), addEventListener("mouseup", k);
  }), x(() => {
    a.value.removeEventListener("touchstart", L), a.value.removeEventListener("mousedown", L), removeEventListener("touchmove", E), removeEventListener("mousemove", E), removeEventListener("touchend", k), removeEventListener("mouseup", k);
  })), {
    hasMoved: f,
    draggableStyles: C,
    isDragged: d
  };
}
const Xe = M({
  name: "VtToast",
  components: { ProgressBar: ye, VtIcon: ze },
  props: {
    status: {
      type: Object,
      required: !0
    },
    baseIconClass: {
      type: String,
      default: ""
    },
    delayed: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["vtRemove"],
  setup: (e, t) => {
    const n = p(!1), r = p(!0), l = P(), d = p(), u = w(() => {
      const s = {};
      return e.status.mode === "loader" && (s["vt-cursor-wait"] = !0), s["vt-theme-" + e.status.theme] = !0, s;
    }), i = w(() => ["prompt", "loader"].indexOf(e.status.mode) === -1), a = w(() => Object.keys(e.status.answers)), f = () => {
      i.value && !L.value && (l.emit("vtDismissed", { id: e.status.id }), t.emit("vtRemove"));
    }, $ = () => {
      i.value && L.value && (l.emit("vtDismissed", { id: e.status.id }), t.emit("vtRemove"));
    }, h = (s) => {
      l.emit("vtPromptResponse", {
        id: e.status.id,
        response: s
      }), t.emit("vtRemove");
    }, C = () => {
      var v;
      Math.ceil(((v = d.value) == null ? void 0 : v.progress) ?? NaN) >= 100 && i.value && (l.emit("vtFinished", { id: e.status.id }), t.emit("vtRemove"));
    }, { hasMoved: L, draggableStyles: E, isDragged: k } = Ue(e, $), c = () => r.value = !1, o = () => r.value = !0;
    return X(() => {
      e.status.pauseOnFocusLoss && (addEventListener("blur", c), addEventListener("focus", o));
    }), re(() => {
      e.status.pauseOnFocusLoss && (removeEventListener("blur", c), removeEventListener("focus", o));
    }), {
      isHovered: n,
      notificationClass: u,
      isNotification: i,
      respond: h,
      dismiss: f,
      draggableStyles: E,
      progressBar: d,
      answers: a,
      finish: C,
      isDragged: k,
      hasFocus: r
    };
  }
}), Ye = ["data-delayed"], We = { class: "vt-content" }, Ge = ["textContent"], Ke = ["innerHTML"], Qe = {
  key: 2,
  class: "vt-buttons"
}, Ze = ["onClick", "textContent"];
function Je(e, t, n, r, l, d) {
  const u = A("ProgressBar"), i = A("VtIcon");
  return g(), m("div", {
    class: N(["vt-notification", e.notificationClass]),
    role: "alert",
    style: R(e.draggableStyles),
    draggable: "false",
    "data-delayed": e.delayed,
    onClick: t[0] || (t[0] = (...a) => e.dismiss && e.dismiss(...a)),
    onMouseenter: t[1] || (t[1] = (a) => e.isHovered = !0),
    onMouseleave: t[2] || (t[2] = (a) => e.isHovered = !1),
    onTouchstart: t[3] || (t[3] = (a) => e.isHovered = !0),
    onTouchend: t[4] || (t[4] = (a) => e.isHovered = !1)
  }, [
    e.isNotification && e.status.canTimeout ? ie((g(), F(u, {
      key: 0,
      id: e.status.id,
      ref: "progressBar",
      duration: e.status.duration,
      "is-paused": e.status.pauseOnHover && e.isHovered || !e.hasFocus || e.isDragged,
      onVtFinished: e.finish
    }, null, 8, ["id", "duration", "is-paused", "onVtFinished"])), [
      [ae, !e.status.hideProgressbar]
    ]) : _("", !0),
    T("div", We, [
      e.status.title ? (g(), m("h2", {
        key: 0,
        class: "vt-title",
        textContent: G(e.status.title)
      }, null, 8, Ge)) : _("", !0),
      e.status.body ? (g(), m("p", {
        key: 1,
        class: "vt-paragraph",
        innerHTML: e.status.body
      }, null, 8, Ke)) : _("", !0)
    ]),
    e.status.iconEnabled ? (g(), F(i, {
      key: 1,
      mode: e.status.mode,
      type: e.status.type,
      icon: e.status.icon,
      "base-icon-class": e.baseIconClass
    }, null, 8, ["mode", "type", "icon", "base-icon-class"])) : _("", !0),
    e.status.mode === "prompt" ? (g(), m("div", Qe, [
      (g(!0), m(te, null, ne(e.answers, (a, f) => (g(), m("button", {
        key: f,
        onClick: ($) => e.respond(e.status.answers[a]),
        textContent: G(a)
      }, null, 8, Ze))), 128))
    ])) : _("", !0)
  ], 46, Ye);
}
const xe = /* @__PURE__ */ j(Xe, [["render", Je]]), Z = le({
  singular: !1,
  withBackdrop: !1,
  backdrop: "rgba(0, 0, 0, 0.2)",
  position: "bottom-right",
  defaultTitle: !0,
  canTimeout: !0,
  pauseOnHover: !1,
  pauseOnFocusLoss: !0,
  iconEnabled: !0,
  draggable: !0,
  dragThreshold: 0.75,
  hideProgressbar: !1,
  errorDuration: 8e3,
  successDuration: 4e3,
  warningInfoDuration: 6e3,
  theme: "dark",
  baseIconClass: "",
  orderLatest: !0,
  transition: void 0,
  oneType: !1,
  maxToasts: 6,
  customNotifications: {}
});
function q() {
  return {
    settings: de(Z),
    updateSettings: (e, t) => {
      let n = {};
      return typeof e == "object" && t === void 0 ? n = e : typeof e == "string" && (n = { [e]: t }), Object.assign(Z, n);
    }
  };
}
const et = M({
  name: "VtTransition",
  props: {
    transition: { type: [String, Object], required: !0 },
    position: { type: String, required: !0 }
  },
  setup: (e) => {
    const { settings: t } = q(), n = ee();
    return {
      beforeEnter: (i) => {
        const a = n == null ? void 0 : n.vnode.el;
        for (const f of a.children)
          delete f.dataset.delayed;
        i.dataset.delayed && i.classList.add("vt-move");
      },
      afterEnter: (i) => {
        i.removeAttribute("data-delayed"), i.classList.remove("vt-move");
      },
      beforeLeave: (i) => {
        for (let a = 0; a < i.parentNode.childNodes.length; a++)
          i.parentNode.childNodes[a].isSameNode(i) || (i.parentElement.children[a].dataset.delayed = "true");
      },
      leave: (i) => {
        if (t.singular || t.oneType && i.parentNode.childNodes.length === 1)
          return;
        const a = e.position.split("-"), { height: f, width: $, marginBottom: h } = window.getComputedStyle(i);
        i.style.left = String(i.offsetLeft - (i.parentNode.childNodes.length === 1 ? parseInt($) / 2 : 0)) + "px", i.style.top = String(i.offsetTop) + "px", a[0] === "center" && (i.style.top = String(parseInt(i.style.top) - parseInt(f) / 2 - parseInt(h) / 2) + "px"), a[0] === "bottom" && (i.style.top = String(parseInt(i.style.top) - parseInt(f) - parseInt(h)) + "px"), i.style.width = $, i.style.position = "absolute";
      }
    };
  }
});
function tt(e, t, n, r, l, d) {
  return g(), F(ue, {
    name: e.transition.name ? e.transition.name : e.transition,
    css: !0,
    tag: "div",
    "move-class": e.transition.moveClass ? e.transition.moveClass : "vt-move",
    onLeave: e.leave,
    onBeforeEnter: e.beforeEnter,
    onAfterEnter: e.afterEnter,
    onBeforeLeave: e.beforeLeave
  }, {
    default: oe(() => [
      ce(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["name", "move-class", "onLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"]);
}
const nt = /* @__PURE__ */ j(et, [["render", tt]]), H = {}, ot = M({
  name: "VueToastify",
  components: {
    VtToast: xe,
    VtTransition: nt
  },
  expose: ["add", "get", "set", "remove", "stopLoader"],
  setup: () => {
    const e = p([]), t = p([]), { settings: n, updateSettings: r } = q(), l = P(), d = w(() => {
      if (n.transition)
        return n.transition;
      const o = n.position.split("-");
      return o[1] === "left" ? "vt-left" : o[1] === "center" ? "vt-" + o[0] : "vt-right";
    }), u = w(() => ({
      flexDirection: n.orderLatest && n.position.split("-")[0] === "bottom" ? "column" : "column-reverse"
    })), i = w(() => {
      const o = n.position.split("-"), s = {};
      return o[0] === o[1] ? (s["vt-center-center"] = !0, s) : (s[o[0] === "center" ? "vt-centerY" : "vt-" + o[0]] = !0, s[o[1] === "center" ? "vt-centerX" : "vt-" + o[1]] = !0, s);
    }), a = (o) => e.value.findIndex((s) => s.id === o), f = (o) => t.value.findIndex((s) => s.id === o), $ = (o) => {
      if (o.title)
        return o.title;
      if (I(o.defaultTitle))
        if (o.defaultTitle) {
          if (o.mode === "prompt" || o.mode === "loader")
            return "";
          if (o.type)
            return o.type.charAt(0).toUpperCase() + o.type.slice(1);
        } else
          return "";
      if (n.defaultTitle) {
        if (o.mode === "prompt" || o.mode === "loader")
          return "";
        if (o.type)
          return o.type.charAt(0).toUpperCase() + o.type.slice(1);
      }
      return "Info";
    }, h = (o) => !!e.value.find(
      (s) => (
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        s.mode && s.mode === o.mode || s.type && s.type === o.type
      )
    ), C = (o) => {
      const s = [];
      return typeof o == "string" ? s.push(o) : Array.isArray(o) ? s.push(...o) : s.push(...e.value.filter((v) => v.mode === "loader").map((v) => v.id)), s.forEach((v) => {
        l.emit("vtLoadStop", { id: v }), c(v);
      }), s.length;
    }, L = (o) => {
      const s = Object.assign(
        {},
        o,
        {
          id: Te()
        }
      );
      return s.duration = n.warningInfoDuration, Number(o.duration) > 0 ? s.duration = Number(o.duration) : o.type && (s.duration = o.type === "error" ? n.errorDuration : o.type === "success" ? n.successDuration : n.warningInfoDuration), s.answers = o.answers && Object.keys(o.answers).length > 0 ? o.answers : { Yes: !0, No: !1 }, s.pauseOnHover = I(o.pauseOnHover) ? o.pauseOnHover : n.pauseOnHover, s.pauseOnFocusLoss = I(o.pauseOnFocusLoss) ? o.pauseOnFocusLoss : n.pauseOnFocusLoss, s.hideProgressbar = I(o.hideProgressbar) ? o.hideProgressbar : n.hideProgressbar, s.title = $(o), s.canTimeout = I(o.canTimeout) ? o.canTimeout : n.canTimeout, s.iconEnabled = I(o.iconEnabled) ? o.iconEnabled : n.iconEnabled, o.mode === "prompt" || o.mode === "loader" ? s.draggable = !1 : s.draggable = I(o.draggable) ? o.draggable : n.draggable, s.dragThreshold = o.dragThreshold && we(o.dragThreshold, 0, 5) ? o.dragThreshold : n.dragThreshold, (o.mode === "prompt" || o.mode === "loader") && (s.canTimeout = !1), s.theme = o.theme ? o.theme : n.theme, // if singular and there's 1 already showing
      n.singular && e.value.length > 0 || // if oneType turned on and that type already showing
      n.oneType && h(s) || // if it exceeds the max number of displayed toasts
      e.value.length + 1 >= n.maxToasts ? (s.delay ? setTimeout(() => {
        t.value.push({ ...s, delayed: !0 });
      }, s.delay) : t.value.push({ ...s, delayed: !0 }), t.value.push({ ...s, delayed: !0 }), s.id) : (s.delay ? setTimeout(() => {
        e.value.push(s);
      }, s.delay) : e.value.push(s), s.id);
    }, E = (o) => o ? e.value.find((s) => s.id === o) ?? t.value.find((s) => s.id === o) : [
      ...e.value,
      ...t.value
    ], k = (o, s) => {
      const v = E(o);
      return v ? a(o) !== -1 ? (e.value = e.value.map((B) => B.id === o ? Object.assign(B, s) : B), !0) : (e.value[f(o)] = Object.assign(v, s), !0) : !1;
    }, c = (o) => {
      var v, B, Y, W;
      if (o) {
        let y = f(o);
        return n.singular && y !== -1 ? ((B = (v = t.value.splice(y, 1)[0]).callback) == null || B.call(v), 1) : (y = a(o), y !== -1 ? ((W = (Y = e.value.splice(y, 1)[0]).callback) == null || W.call(Y), 1) : 0);
      }
      const s = e.value.length + t.value.length;
      return e.value.forEach((y) => {
        var V;
        return (V = y.callback) == null ? void 0 : V.call(y);
      }), t.value.forEach((y) => {
        var V;
        return (V = y.callback) == null ? void 0 : V.call(y);
      }), e.value = [], t.value = [], s;
    };
    return z(() => n, (o, s) => {
      if (!o.singular) {
        for (let v = 0; v < o.maxToasts - 1; v++)
          t.value[v] && (h(t.value[v]) || e.value.push(t.value.splice(v, 1)[0]));
        I(H.orderLatest) && (r({ orderLatest: H.orderLatest }), delete H.orderLatest);
        return;
      }
      H.orderLatest = s.orderLatest, r({ orderLatest: !1 });
    }), z(
      () => e.value,
      async (o) => {
        if (t.value.length !== 0) {
          if (await ve(), n.singular) {
            o.length === 0 && e.value.push({
              ...t.value.shift(),
              delayed: !0
            });
            return;
          }
          if (n.oneType)
            return t.value.forEach((s, v) => {
              !h(s) && e.value.length < n.maxToasts && e.value.push({
                ...t.value.splice(v, 1)[0],
                delayed: !0
              });
            });
          e.value.length < n.maxToasts && e.value.push({
            ...t.value.shift(),
            delayed: !0
          });
        }
      },
      { deep: !0 }
    ), {
      toasts: e,
      settings: n,
      positionClasses: i,
      flexDirection: u,
      getTransition: d,
      add: L,
      get: E,
      set: k,
      remove: c,
      stopLoader: C
    };
  }
});
function st(e, t, n, r, l, d) {
  const u = A("VtToast"), i = A("VtTransition");
  return g(), m("div", null, [
    T("div", {
      class: N(["vt-backdrop-hidden", {
        "vt-backdrop-visible": e.toasts.length > 0 && e.settings.withBackdrop
      }]),
      style: R({
        backgroundColor: e.settings.backdrop
      })
    }, null, 6),
    ge(i, {
      class: N(["vt-notification-container", e.positionClasses]),
      style: R(e.flexDirection),
      transition: e.getTransition,
      position: e.settings.position
    }, {
      default: oe(() => [
        (g(!0), m(te, null, ne(e.toasts, (a) => (g(), F(u, {
          key: a.id,
          status: a,
          delayed: !!a.delayed || !1,
          "base-icon-class": e.settings.baseIconClass,
          onVtRemove: (f) => e.remove(a.id)
        }, null, 8, ["status", "delayed", "base-icon-class", "onVtRemove"]))), 128))
      ]),
      _: 1
    }, 8, ["class", "style", "transition", "position"])
  ]);
}
const rt = /* @__PURE__ */ j(ot, [["render", st]]);
let D = {};
const O = (e, t) => (typeof e == "string" && (e = {
  body: e
}), t && (e.title = t), e.type || (e.type = "success"), D.container.add(e)), U = {
  notify: O,
  success: (e, t) => O(e, t),
  info: (e, t) => (typeof e == "string" && (e = {
    body: e
  }), t && (e.title = t), e.type = "info", O(e)),
  warning: (e, t) => (typeof e == "string" && (e = {
    body: e
  }), t && (e.title = t), e.type = "warning", O(e)),
  error: (e, t) => {
    const n = {};
    return typeof e == "string" && (n.body = e), t && (n.title = t), n.type = "error", O(n);
  },
  loader: (e, t) => (typeof e == "string" && (e = {
    body: e
  }), t && (e.title = t), e.mode = "loader", O(e)),
  prompt: async (e) => {
    e.mode = "prompt";
    const t = P(), n = D.container.add(e);
    return new Promise((r) => {
      t.once("vtPromptResponse", (l) => {
        l.id === n && r(l.response);
      });
    });
  },
  stopLoader(e) {
    return D.container.stopLoader(e);
  },
  findToast(e) {
    return D.container.get(e);
  },
  getToasts() {
    return D.container.get();
  },
  updateToast(e, t) {
    return D.container.set(e, t);
  },
  remove(e) {
    return D.container.remove(e);
  },
  settings(e) {
    const t = q();
    return e ? t.updateSettings(e) : t.settings;
  }
};
function vt() {
  return U;
}
const it = Symbol("vue-toastify"), gt = (e, t = {}) => {
  q().updateSettings(t);
  const n = document.createElement("div");
  if (n.setAttribute("id", it.toString()), document.body.appendChild(n), D.container = fe(rt).mount(n), t.customNotifications && Object.entries(t.customNotifications).length > 0) {
    const r = Object.keys(U);
    Object.entries(t.customNotifications).forEach((l) => {
      if (r.includes(l[0]))
        throw new Error(`The method name ${l[0]} is reserved by vue-toastify.`);
      Object.defineProperty(U, l[0], {
        get() {
          return (d, u) => {
            let i = Object.assign({}, l[1]);
            return typeof d == "string" ? i.body = d : i = { ...l[1], ...d }, u && (i.title = u), i.type || (i.type = "success"), D.container.add(i);
          };
        }
      });
    });
  }
};
function at(e, t) {
  const n = e.slice(1), r = parseInt(n, 16), l = r >> 16 & 255, d = r >> 8 & 255, u = r & 255;
  return `#${[
    Math.max(0, l - t),
    Math.max(0, d - t),
    Math.max(0, u - t)
  ].map((a) => a.toString(16).padStart(2, "0")).join("")}`;
}
function lt(e, t) {
  const n = e.slice(1), r = parseInt(n, 16), l = r >> 16 & 255, d = r >> 8 & 255, u = r & 255;
  return `#${[
    Math.min(255, l + t),
    Math.min(255, d + t),
    Math.min(255, u + t)
  ].map((a) => a.toString(16).padStart(2, "0")).join("")}`;
}
function dt(e) {
  const t = {
    red: parseInt(e.slice(1, 3), 16),
    green: parseInt(e.slice(3, 5), 16),
    blue: parseInt(e.slice(5, 7), 16)
  };
  for (const [d, u] of Object.entries(t)) {
    let i = u / 255;
    i < 0.03928 ? i /= 12.92 : i = ((i + 0.055) / 1.055) ** 2, t[d] = i;
  }
  const n = t.red * 0.2126, r = t.green * 0.7152, l = t.blue * 0.0722;
  return n + r + l;
}
function b(e, t) {
  return dt(e) > 0.4 ? at(e, t) : lt(e, t);
}
function ut(e, t) {
  return [
    `.vt-theme-${e} {
            background-color: ${t};
        }`,
    `.vt-theme-${e} > .vt-progress-bar {
            background-color: ${b(t, 10)};
        }`,
    `.vt-theme-${e} > .vt-progress-bar > .vt-progress {
            background-color: ${b(t, 30)};
        }`,
    `.vt-theme-${e} > .vt-content > .vt-title {
            color: ${b(t, 75)};
        }`,
    `.vt-theme-${e} > .vt-content > .vt-paragraph {
            color: ${b(t, 75)};
        }`,
    `.vt-theme-${e} > .vt-buttons > .button {
            background-color: ${b(t, 10)};
            color: ${b(t, 75)};
            border: 1px solid ${b(t, 10)};
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }`,
    `.vt-theme-${e} > .vt-buttons > .button:hover {
            background-color: ${b(t, 65)};
            color: ${b(t, 5)};
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }`,
    `.vt-theme-${e} > .vt-prompt {
            border-color: ${b(t, 70)};
        }`,
    `.vt-theme-${e} > .vt-prompt > .vt-icon > .svg {
            fill: ${b(t, 70)};
        }`,
    `.vt-theme-${e} > .vt-icon-container > .vt-spinner {
            border: 2px solid ${b(t, 30)};
            border-top: 2px solid ${b(t, 90)};
        }`
  ];
}
const J = Symbol("vue-toastify-themes");
function ft(e, t) {
  let n = document.getElementById(J.toString());
  n || (n = document.createElement("style"), n.type = "text/css", n.id = J.toString(), document.head.appendChild(n)), ut(e, t).forEach((r) => n.sheet.insertRule(
    r.replaceAll("  ", "").replaceAll(`
`, " ")
  ));
}
export {
  ft as createVtTheme,
  gt as default,
  ut as getCssRules,
  vt as useToast,
  P as useVtEvents,
  q as useVtSettings
};
